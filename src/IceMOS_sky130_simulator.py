import os
import os
import subprocess
import sys
import time
from IceMOS_sky130_netlist_generator import NetlistGeneratorSky130


class IceMOS_simulator_sky130:
    """
    Simulator class for running SPICE netlists generated for SKY130 simulations.

    This class uses ngspice in batch mode to simulate netlists that were generated
    based on extracted bin models. It supports simulating both IV (IDRAIN vs. VGATE)
    and IV_VDS (IDRAIN vs. VDRAIN with VGATE sweep) simulations. The simulation
    output files are created in the same folder as the netlist.

    All simulations use the 'modified' netlist generated by the netlist generator.
    """

    def __init__(self, original_model_file):
        """
        Initialize the simulator with the path to the original SPICE model file.
        
        :param original_model_file: Path to the original SPICE model file (e.g., "sky130_fd_pr__nfet_01v8.pm3.spice").
        """
        self.original_model_file = original_model_file
        self.generator = NetlistGeneratorSky130(original_model_file)

    def _simulate_netlist(self, netlist_path):
        """
        Simulate the given netlist using ngspice in batch mode.
        
        This method converts the provided netlist path to an absolute path and sets the 
        working directory to the netlist's folder so that all output files (e.g., .raw, .csv)
        are generated in that folder.
        
        :param netlist_path: Path to the netlist file to simulate.
        :return: The stdout output of the simulation.
        :raises RuntimeError: If the simulation fails.
        """
        # Convert netlist_path to an absolute path
        netlist_path = os.path.abspath(netlist_path)
        cmd = ["ngspice", "-b", netlist_path]
        netlist_dir = os.path.dirname(netlist_path)
        print(f"Running simulation with command: {' '.join(cmd)}")
        print(f"Simulation working directory: {netlist_dir}")
        
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                   universal_newlines=True, cwd=netlist_dir)
        
        spinner = ['-', '\\', '|', '/']
        i = 0
        while process.poll() is None:
            sys.stdout.write("\rSimulating... " + spinner[i % len(spinner)])
            sys.stdout.flush()
            time.sleep(0.05)
            i += 1
        sys.stdout.write("\rSimulation complete.            \n")
        sys.stdout.flush()
        
        stdout, stderr = process.communicate()
        if process.returncode != 0:
            print("Simulation error:")
            print(stderr)
            raise RuntimeError("Netlist simulation failed.")
        else:
            print("ngspice stdout:")
            print(stdout)
            print("ngspice stderr:")
            print(stderr)
        return stdout

    def simulate_iv(self, device_type, bin_number=None, W=None, L=None,
                    vgate_start=0, vgate_stop=1.8, vgate_step=0.1):
        """
        Generate and simulate an IV netlist (IDRAIN vs. VGATE) for the specified device.
        
        The bin is determined either by an explicit bin number or by provided transistor dimensions (W, L).
        Always uses the 'modified' netlist.
        
        :param device_type: 'nch' for NMOS or 'pch' for PMOS.
        :param bin_number: (Optional) The bin number to simulate.
        :param W: (Optional) Transistor width in µm.
        :param L: (Optional) Transistor length in µm.
        :param vgate_start: Starting voltage for the VGATE sweep.
        :param vgate_stop: Ending voltage for the VGATE sweep.
        :param vgate_step: Voltage step for the VGATE sweep.
        :return: The stdout output from the simulation.
        """
        netlists = self.generator.generate_iv_netlists(
            device_type=device_type, bin_number=bin_number, W=W, L=L,
            vgate_start=vgate_start, vgate_stop=vgate_stop, vgate_step=vgate_step)
        netlist_path = netlists["modified"]
        print(f"Simulating IV netlist: {netlist_path}")
        return self._simulate_netlist(netlist_path)
    
    def simulate_id_vs_vds_sweep_vg(self, device_type, bin_number=None, W=None, L=None,
                          vgs_start=0, vgs_stop=1.8, vgs_step=0.6,
                          vds_start=0, vds_stop=1.8, vds_step=0.1):
        """
        Generate and simulate an IV_VDS netlist (IDRAIN vs. VDRAIN with a VGATE sweep) for the specified device.
        
        The bin is determined either by an explicit bin number or by the provided transistor dimensions (W, L).
        Always uses the 'modified' netlist.
        
        :param device_type: 'nch'.
        :param bin_number: (Optional) The bin number to simulate.
        :param W: (Optional) Transistor width in µm.
        :param L: (Optional) Transistor length in µm.
        :param vgs_start: Starting voltage for the VGS sweep.
        :param vgs_stop: Ending voltage for the VGS sweep.
        :param vgs_step: Voltage step for the VGS sweep.
        :param vds_start: Starting voltage for the VDS sweep (within the VGS loop).
        :param vds_stop: Ending voltage for the VDS sweep.
        :param vds_step: Voltage step for the VDS sweep.
        :return: The stdout output from the simulation.
        """
        netlists = self.generator.generate_iv_vds_netlists(
            device_type=device_type, bin_number=bin_number, W=W, L=L,
            vgs_start=vgs_start, vgs_stop=vgs_stop, vgs_step=vgs_step,
            vds_start=vds_start, vds_stop=vds_stop, vds_step=vds_step)
        netlist_path = netlists["modified"]
        print(f"Simulating IV VDS netlist: {netlist_path}")
        return self._simulate_netlist(netlist_path)

## TODO: fix vgs for vsg
    def simulate_is_vs_vsd_sweep_vg(self, device_type, bin_number=None, W=None, L=None,
                        vsg_start=0, vsg_stop=1.8, vsg_step=0.2,
                        vsd_start=0, vsd_stop=1.8, vsd_step=0.1):
        """
        Generate and simulate an IV_VSD netlist (IDRAIN vs. VSOURCE with a VGATE sweep) for the specified device.

        The bin is determined either by an explicit bin number or by the provided transistor dimensions (W, L).
        Always uses the 'modified' netlist.

        :param device_type: 'pch' for PMOS.
        :param bin_number: (Optional) The bin number to simulate.
        :param W: (Optional) Transistor width in µm.
        :param L: (Optional) Transistor length in µm.
        :param vsg_start: Starting voltage for the VSG sweep.
        :param vsg_stop: Ending voltage for the VSG sweep.
        :param vsg_step: Voltage step for the VSG sweep.
        :param vsg_start: Starting voltage for the VSD sweep (within the VSG loop).
        :param vsd_stop: Ending voltage for the VDS sweep.
        :param vsd_step: Voltage step for the VSD sweep.
        :return: The stdout output from the simulation.
        """

        netlists = self.generator.generate_iv_vds_netlists(
            device_type=device_type, bin_number=bin_number, W=W, L=L,
            vgs_start=vsg_start, vgs_stop=vsg_stop, vgs_step=vsg_step,
            vsd_start=vsd_start, vsd_stop=vsd_stop, vsd_step=vsd_step)
        netlist_path = netlists["modified"]
        print(f"Simulating IV VSD netlist: {netlist_path}")
        return self._simulate_netlist(netlist_path)


    def plot_iv_results_qt(self, device_type, bin_number, csv_filename=None):
        """
        Plot the IV simulation results (IDRAIN vs. VGATE) using PyQtGraph for interactive plotting.

        Reads the CSV file (assumed to be space-delimited with no header) generated by the IV simulation,
        assigns column names ("VG" and "ID" for NMOS, "VG" and "IS" for PMOS), and displays an interactive plot
        using PyQtGraph. This method does not block execution.

        :param device_type: 'nch' for NMOS or 'pch' for PMOS.
        :param bin_number: The bin number used in the simulation.
        :param csv_filename: (Optional) CSV filename; defaults to "IV_ID_vs_VG.csv".
        :return: The PyQtGraph window object.
        """
        import pandas as pd
        import pyqtgraph as pg
        from PyQt5 import QtWidgets
        import sys

        device_type = device_type.lower()
        if csv_filename is None:
            csv_filename = "IV_ID_vs_VG.csv"

        folder = os.path.join("circuits", device_type, f"bin_{bin_number}", "results_IV_ID_vs_VG")
        csv_path = os.path.join(folder, csv_filename)
        if not os.path.exists(csv_path):
            print(f"CSV file {csv_path} not found. Please run the simulation first.")
            return

        try:
            df = pd.read_csv(csv_path, delim_whitespace=True, header=None)
        except Exception as e:
            print(f"Error reading CSV file {csv_path}: {e}")
            return

        if device_type == "nch":
            df.columns = ["VG", "ID"]
            y_label = "Drain Current (IDS)"
            title = f"NMOS IDS vs VGS (Bin {bin_number})"
        else:
            df.columns = ["VG", "ID"]  ## ID here is actually ISD (todo: fix this)
            y_label = "Source-Drain Current (ISD)"
            title = f"PMOS ISD vs VSG (Bin {bin_number})"

        # Get or create the QApplication.
        app = QtWidgets.QApplication.instance()
        created_app = False
        if app is None:
            app = QtWidgets.QApplication(sys.argv)
            created_app = True

        # Create the PyQtGraph window.
        win = pg.GraphicsLayoutWidget(title=title)
        win.resize(800, 600)
        p = win.addPlot(title=title)
        p.setLabel('left', y_label)
        if device_type == 'nch': p.setLabel('bottom', "Gate Voltage (VGS)")
        else: p.setLabel('bottom', "Gate Voltage (VSG)")
        p.showGrid(x=True, y=True)
        p.plot(df["VG"].values, df.iloc[:, 1].values,
               pen=pg.mkPen(color='b', width=2),
               symbol='o', symbolSize=5)
        win.show()

        # Process events so that the window appears but do not block.
        if created_app:
            QtWidgets.QApplication.processEvents()
        return win

    def plot_iv_vds_results_qt(self, device_type, bin_number, csv_folder=None):
        """
        Plot the IV VDS simulation results using PyQtGraph in a non-blocking manner.

        This method searches for CSV files in the sweep results folder (default:
        circuits/<device_type>/bin_<bin_number>/sweep_IV_results). Each CSV file is assumed to be
        space-delimited with no header and to contain six columns.

        For NMOS (nch), columns are assigned as:
          ["V(VDS)", "V(VGS)", "V(VDS)_dup", "I(IDS)", "V(VDS)_dup2", "I(VDSM)"]
        For PMOS (pch), columns are assigned as:
          ["V(VSD)", "V(VGS)", "V(VSD)_dup", "I(SD)", "V(VSD)_dup2", "I(VSDM)"]

        The VGS value is extracted from the filename (the text after the last '_' and before '.csv').
        For each file, the curve of current vs. voltage is plotted:
          - NMOS: I(VDSM) vs. V(VDS)
          - PMOS: I(VSDM) vs. V(VSD)

        All curves are added to a single interactive plot with a legend.

        :param device_type: 'nch' for NMOS or 'pch' for PMOS.
        :param bin_number: The bin number used in the simulation.
        :param csv_folder: (Optional) Folder where CSV files are located. Defaults to:
                           circuits/<device_type>/bin_<bin_number>/sweep_IV_results
        :return: The PyQtGraph window object.
        """
        import os
        import re
        import pandas as pd
        import pyqtgraph as pg
        from PyQt5 import QtWidgets
        import sys

        device_type = device_type.lower()
        if csv_folder is None:
            if device_type == 'nch': csv_folder = os.path.join("circuits", device_type, f"bin_{bin_number}", "results_IV_IDS_vs_VDS_for_VG_sweep")
            else: csv_folder = os.path.join("circuits", device_type, f"bin_{bin_number}", "results_IV_ISD_vs_VSD_for_VG_sweep")
        if not os.path.exists(csv_folder):
            print(f"CSV folder {csv_folder} not found. Please run the IV VDS simulation first.")
            return

        csv_files = [f for f in os.listdir(csv_folder) if f.endswith(".csv")]
        csv_files.sort()
        if not csv_files:
            print(f"No CSV files found in {csv_folder}. Please run the simulation first.")
            return

        # For NMOS and PMOS, set appropriate column names.
        if device_type == "nch":
            col_names = ["V(VDS)", "V(VGS)", "V(VDS)_dup", "I(IDS)", "V(VDS)_dup2", "I(VDSM)"]
            x_col = "V(VDS)"
            y_col = "I(VDSM)"
            plot_title = f"NMOS IDS vs VDS Curves (Bin {bin_number})"
        else:
            col_names = ["V(VSD)", "V(VG)", "V(VSD)_dup", "I(ISD)", "V(VSD)_dup", "I(VSDM)"]
            x_col = "V(VSD)"
            y_col = "I(VSDM)"
            plot_title = f"PMOS ISD vs VSD Curves (Bin {bin_number})"

        # Get or create the QApplication.
        app = QtWidgets.QApplication.instance()
        created_app = False
        if app is None:
            app = QtWidgets.QApplication(sys.argv)
            created_app = True

        # Create the PyQtGraph window.
        win = pg.GraphicsLayoutWidget(title=plot_title)
        win.resize(800, 600)
        p = win.addPlot(title=plot_title)
        p.setLabel('left', y_col)
        p.setLabel('bottom', x_col)
        p.showGrid(x=True, y=True)
        legend = p.addLegend(offset=(10, 10))

        # Process each CSV file.
        for csv_file in csv_files:
            # Extract VGS value: text after the last underscore before ".csv"
            try:
                vgs_str = csv_file.rsplit('_', 1)[-1].replace('.csv', '')
            except Exception as e:
                print(f"Error extracting VGS from {csv_file}: {e}")
                continue

            csv_path = os.path.join(csv_folder, csv_file)
            try:
                df = pd.read_csv(csv_path, sep=r'\s+', header=None)
                df.columns = col_names

            except Exception as e:
                print(f"Error reading CSV file {csv_path}: {e}")
                continue

            # Plot current vs. voltage.
            if device_type == 'nch': plot_name = f"VGS = {vgs_str} V"
            else: plot_name = f"VSG = {vgs_str} V"
            curve = p.plot(df[x_col].values, df[y_col].values,
                           pen=pg.mkPen(width=2),
                           symbol='o', symbolSize=5)
            legend.addItem(curve, plot_name)

        win.show()
        if created_app:
            QtWidgets.QApplication.processEvents()
        return win
